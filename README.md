# Comp-Graphic-Final
Approaching software design begins with a clear understanding of both the problem and the end-user experience. For this project, I focused on balancing visual design with performance. My approach to designing software has always been rooted in creating modular, maintainable code that can grow with the complexity of the project. This 3D scene project sharpened that perspective by requiring a structured breakdown of components such as the camera system, object rendering, lighting, and input handling.

Working on this project helped me develop stronger object-oriented design skills, particularly in organizing functionality through dedicated classes like SceneManager and ViewManager. By clearly separating rendering logic from input handling and camera control, I was able to build a more maintainable codebase and reduce the chances of introducing errors during development. This experience reinforced the value of clean architecture, modularity, and separation of concerns, principles that are universally applicable across future software development work.

The design process I followed began with research and sketching out what I wanted the scene to look like. From there, I identified the technical needs: shaders, textures, user input, and 3D geometry. I then implemented the project in stages, testing frequently and adjusting my plan as I ran into obstacles or discovered better methods. This iterative workflow allowed me to learn through trial and error and evolve the design as my understanding deepened.

These tactics such as breaking down the problem, building incrementally, and testing regularly will carry over into any future work I take on. Whether it's a larger software application, a game engine project, or even a web-based visualization tool, these habits make the development process smoother and more scalable.

When developing programs, I now start with the most essential functions, ensuring the core architecture is sound before layering on complexity. With this 3D scene, I had to adapt new strategies for handling graphical assets and real-time rendering performance. I learned to manage GPU resources carefully, apply transformations in shaders, and fine-tune user interactions to create a smooth experience.

Iteration played a key role throughout the milestones. I frequently refactored code, improved texture mapping, tweaked lighting parameters, and rebuilt control logic for smoother camera movement. These small but continual improvements accumulated into a final product that was far more polished than my initial version.

My approach to developing code has grown more methodical over the course of this project. I've moved away from trial-and-error coding and toward planning structures and responsibilities from the beginning, always thinking ahead about scalability and maintainability.

Looking toward the future, computer science gives me a powerful set of tools to reach my goals, whether in game design, immersive simulation, or data visualization. It’s not just about programming; it's about solving problems creatively and efficiently.

The knowledge I’ve gained from computational graphics such as managing transformations, lighting models, and camera logic has broadened my understanding of how digital environments are constructed. These skills will benefit me academically as I take on more advanced computer science or engineering courses that involve simulation or modeling.

Professionally, computational graphics and visualizations offer me new ways to communicate data, ideas, and experiences. Whether building interactive environments or visualizing complex systems, the ability to represent abstract concepts visually is a vital skill across industries like gaming, AR/VR, architecture, and scientific research.
